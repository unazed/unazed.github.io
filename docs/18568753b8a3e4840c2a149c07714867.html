<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/pygments.css">
    <link rel="stylesheet" href="/css/styles.css">
    <title>STM32H7x notes</title>
  </head>
  <body>
    <header>
      <p>m. taujanskas</p>
      <p>-</p>
      
  <p style="margin-left:1em;font-style:italic;">&gt; STM32H7x notes</p>

    </header>
    <main>
      
  <p>The reference quietly pad some certain register fields without explicitly stating there's a reserved area between them, leaving you to figure it out from the offsets. Good thing we're validating sizes otherwise that would have been obnoxious to figure out.</p>
<h2>What's the difference between different general-purpose timer groups?</h2>
<p><code>TIM2-5</code> + <code>TIM23-24</code>:
  16/32 bit reload counters
  - 16 bit only on tim3/4
  - 32 bit on the rest
  16 bit programmable prescaler
  Synchronization circuit
  4 independent channels
  - input capture, output compare, PWM (edge/center-aligned), one pulse
  trigger input for ext. clock
  Supports incremental (quadrature) encoder and hall-sensor circuitry
  interrupt generation for:
  - update, trigger event, input capture, output compare</p>
<p><code>TIM12-14</code>:
  16 bit reload counter
  16 bit programmable prescaler
  Synchronization circuit (ONLY for tim12)
  up to 2 independent channels (ONLY 1 for tim12)
  - input capture, output compare, PWM (edge-aligned), one pulse
  interrupt generation for:
  - update, trigger event, input capture, output compare
      NO trigger event for tim13-14</p>
<p><code>TIM15-17</code>:
  16 bit reload counter
  16 bit programmable prescaler
  Break input to put the timerâ€™s output signals in the reset state or a known state
  Complementary outputs with programmable dead-time
  Repetition counter to update the timer registers only after a given number of cycles of the counter
  Synchronization circuit (ONLY for tim15)
  up to 2 independent channels (ONLY 1 for tim16-17)
  - input capture, output compare, PWM (edge-aligned), one pulse
  interrupt generation for:
  - update, trigger event, input capture, output compare
      NO trigger event for tim16-17</p>
<p>Basically TIM2-5 and TIM23-24 are the most versatile, and then TIM12-14 seem the simplest, and TIM15-17 have some special functionality that might be useful for niche applications.</p>
<h2>Digital-analog converter (DAC)</h2>
<p><code>DAC1_OUT1</code> on <code>PA4</code>, <code>DAC1_OUT2</code> on <code>PA5</code>.
We're working with pulse-code modulated (PCM) media which is sampled at 22,050Hz and represented by unsigned little-endian 8-bit units. So, we're working with 8-bit right-aligned data which we must write to <code>DAC_DHR8Rx</code>, which is subsequently converted to the internal DHR register, and after $t_{settling}$, the output voltage is available on the appropriate chip pin.</p>
<p>The output voltage is determined between 0 and $\text{DACoutput}$, where:
$$\text{DACoutput} = V_{REF} * \frac{\text{DOR}}{4096}$$
Where DOR is the data-output register, determined by the data-holding register (DHR.)</p>
<p>The DAC has two channels, though we only need 1. We need to set <code>TSEL</code> appropriately to sample at an appropriate frequency, i.e. from the timer which we are using to generate the 22kHz signal, as well as <code>TEN</code> and <code>EN</code> to enable triggers and the DAC channel itself.
The appropriate timer signal is <code>dac_chx_trgy</code> where <code>y</code> is packed into 4-bits in <code>TSEL</code>.</p>
<h2>Double-buffering, circular buffers, integrating with the DAC</h2>
<p>First we need to enable the appropriate clocks for <code>TIM6</code>, <code>DAC1</code> and <code>USART2</code>.
Then enable AF7 on <code>GPIOA</code> so we can receive USART data on <code>PA10</code>.
To configure USART, we enable the receive-flag, and configure our baud-rate to <em>at least</em> 22kHz, but 57600 or 115200 are fairly standard baud-rates which will reduce latency/jitter.
Then, we need to configure DMA on the USART side. Provide a tunable parameter which determines the sample buffer-size, e.g. if we store 256 8-bit samples then we will have $256 / 22.05 = 11.61\text{ms}$ of audio data buffered from our USART transmitter.
Since we're double-buffering, by the time first half is ready to be processed--assuming a sufficient baud-rate--the second half will also be ready, and so a continuous stream will exist for the DAC to process.
1. Enable <code>DMA.SxTRBUFF</code> enabled since the manual says it's necessary for USART
2. Enable <code>DMA.SxCR.CIRC</code> on USART for circular buffering so that new data will overwrite from the beginning of the buffer: hopefully we've processed it!
3. Enable <code>DMA.SxCR.DBM</code> for double-buffering mode, <code>DMA_SxM0AR</code> and <code>DMA_SxM1AR</code> are the target buffers whose pointers are swapped on transmission complete (TC.)
4. Enable <code>DMA.SxCR.HTIE</code> (half-transmission) and <code>DMA.SxCR.TCIE</code> (TC) interrupts
   - On half-transmission: we have data ready for the DAC! Set a flag so that on the next <code>TIM6</code> cycle it knows that we're happy for it to consume the audio data in the first buffer
   - On transmission completion: the second audio data buffer is ready, so it should be consumed as long as the first data buffer was also consumed. We should not underrun USART and attempt to receive more data while either indicator flags are still active.</p>
<h2>Voltage scaling</h2>
<p><code>PWR.D3CR.VOS</code> configures the voltage scaling level for the system clock, though by that it means it <em>enables</em> the ability to clock beyond certain thresholds, but by itself doesn't affect anything. Variable system clock frequency scaling can be performed by using PLL as the clock source, scaling against another clock like HSE/HSI/CSI up or down based on tunable parameters.</p>
<h2>Timer clock frequency</h2>
<p><img src="img//Pasted image 20250812171706.png" style="display:block;margin:0 auto;" /></p>
<p>Odd quirk, if the AHB clock is divided by a factor of 2 or more, the timer clock runs at twice the AHB's frequency.</p>
<p>Regardless, if we want to generate a sample event at 22.05kHz, we need to "clock" when our overflow event occurs, which is determined by both the prescaler and autoreload value:
$$f_{\text{OVERFLOW}} = \frac{f_{\text{TIM6}}}{(\text{PSC} + 1)<em>(\text{ARR}+1)}$$
Both denominator expressions added by 1 to avoid division-by-zero. So, considering we have $f_{\text{TIM6}}$ as:
$$f_{\text{TIM6}} = n</em>f_\text{HCLK},~n=2~\text{iff.}~(\text{D2PPRE1} \geq 4)~\text{else}~1$$
We need to optimise $\text{PSC}$ to improve clock granularity, and then refine it down to 22.05kHz with an appropriate $\text{ARR}$ value. Consider:
$$(\text{ARR}+1)(\text{PSC}+1) = \frac{f_\text{TIM6}}{22050~\text{Hz}~[f_\text{OVERFLOW}]}$$
If we let $\text{ARR} = \text{PSC}$, then we have:
$$\begin{aligned}
\text{ARR}^2 + 2\text{ARR} + 1 - C &amp;= 0 \
\to [\text{ARR} = \text{PSC}] &amp;= \sqrt{\frac{f_\text{TIM6}}{22050}} - 1
\end{aligned}$$
Which for a 4MHz clock, we calculate 12.47 (2 d.p.), although we deviate $\pm 8\%$ with rounding error, which is fairly substantial.</p>

    </main>
    <footer>
      <hr>
      
  <a href="/">&gt; home</a>

    </footer>
  </body>
</html>