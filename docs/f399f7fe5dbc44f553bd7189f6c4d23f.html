<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/pygments.css">
    <link rel="stylesheet" href="/css/styles.css">
    <title>urv86t (RISC-V to x86 transpiler)</title>
  </head>
  <body>
    <header>
      <p>m. taujanskas</p>
      <p>-</p>
      
  <p style="margin-left:1em;font-style:italic;">&gt; urv86t (RISC-V to x86 transpiler)</p>

    </header>
    <main>
      
  <h2>Motivation</h2>
<p>I wanted to build <code>urv86t</code> (short for the Ultimate RISC-V to x86 Transpiler) as a little toy-project to delve into the nasty business of binary format parsing, emulation, and cross-architecture recompilation. In particular, the weaknesses I wanted to reinforce within my knowledge were working with the LLVM ecosystem, and being able to put together a cohesive implementation of a non-trivial standard.
Technically, it would be more generally classifiable as a RISC-V to XY transpiler--LLVM-permitting--but my key focus wasn't to expand my knowledge of the x86 architecture; and, since LLVM appealed more in terms of its applicability to the wider field of compiler development, I opted to enroll into that learning curve instead.</p>
<h2>Architecture</h2>
<p>A simplified version of the programming architecture is represented below. It resembles a simple Harvard-based emulation engine with an unpipelined single-core FDE-cycle working over a virtualised memory space generated by the ELF parser. Essentially, creating an emulation environment from an ELF executable. </p>
<p><img src="img//urv86t-simple.png" /></p>
<p>Note that we must adhere to a few layers of ABIs/standard conventions within the implementation. The highest level is dictated by the <a href="https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view?pli=1">RISC-V unprivileged specification</a>, which determines the instruction/extension-level details, alignment constraints, etc.. Moving closer to software, <a href="https://d3s.mff.cuni.cz/files/teaching/nswi200/202324/doc/riscv-abi.pdf">various ABIs</a> must also be specified for calling conventions (which subsequently gives proper names the registers,) and other details pertinent to the ELF/DWARF formats.</p>
<h3>Emulation context</h3>
<p>The <em>Emulation Context</em> store should be self-explanatory: necessary for the FDE-cycle to read/write state variables, like base/extension registers, a suspension flag, the program counter, and further metadata relevant for later stages.</p>
<h3>ELF parser and virtualised memory map</h3>
<p>The <em>Virtualised memory map</em> is supplemented by the ELF parsing stage, or more generally any pre-loading stage. It designates memory regions to the emulation engine, which then allow memory-accessing instructions to correctly map to the correct address in-memory. Below are the two relevant structural definitions:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">elf_load_region</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">vma_base</span><span class="p">;</span>
<span class="w">  </span><span class="n">u8</span><span class="o">*</span><span class="w"> </span><span class="n">mem_base</span><span class="p">;</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">sz_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">sz_reserved</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elf_context</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">elf_load_region</span><span class="o">*</span><span class="w"> </span><span class="n">load_regions</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nr_regions</span><span class="p">;</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">entry_point</span><span class="p">;</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">bp</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">elfctx_t</span><span class="p">;</span>
</code></pre></div>

<p><code>bp</code> and <code>sp</code> are stored fixed within the ELF context since they are typically defined after the memory mappings for the rest of the code/data are determined, though the actual stack pointers are managed in the ABI-specific base registers. Both the stack, and heap are also inserted into <code>elf_context.load_regions</code>, tagged with <code>STACK</code>/<code>HEAP</code> string identifiers respectively, otherwise regular memory regions are tagged as <code>LOAD</code> (following their ELF naming convention.) The heap makes special use of <code>sz_alloc</code> to determine the program break, indicating the number of bytes that have been considered meaningfully allocated from the <code>vma_base</code>.
When an instruction fetches from memory, the address is translated through a helper function:</p>
<div class="codehilite"><pre><span></span><code><span class="n">u8</span><span class="o">*</span>
<span class="nf">elf_vma_to_mem</span><span class="w"> </span><span class="p">(</span><span class="n">elfctx_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_regions</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">load_regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vma_base</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vma_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">sz_reserved</span><span class="p">))</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mem_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vma_base</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Which itself should be self-explanatory.
Misaligned, out-of-bound or illegal instruction fetches terminate the emulator outright, though it should be noted this should just modify the <code>mcause</code> control status register (CSR.)</p>
<h3>System call interface</h3>
<p>Since we're working with ELF executables, we should also try our best to emulate a Linux environment, since there doesn't appear to be any ABI specifications that detail RISC-V on PE executables. Therefore, systems calls should adhere to Linux's specifications detailed on the respective <a href="https://man7.org/linux/man-pages/man2/syscall.2.html">man page</a>, which clarifies that the <code>ecall</code> instruction is used to invoke a system call, with arguments passed across <code>a0</code> to <code>a6</code>, and return values in <code>a0</code>/<code>a1</code> <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>.
The implementation for this is fairly trivial, simply passing through most basic system calls to their real counterpart, but become a little more complex such as in the case of <code>brk</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">RVSYSC_DEFN</span><span class="p">(</span><span class="n">rvsysc_brk</span><span class="p">,</span><span class="w"> </span><span class="n">word_t</span><span class="w"> </span><span class="n">brk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elf_get_heap_region</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">);</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">min_brk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">vma_base</span><span class="p">,</span>
<span class="w">      </span><span class="n">current_brk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_brk</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">sz_alloc</span><span class="p">,</span>
<span class="w">      </span><span class="n">max_brk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">vma_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">sz_reserved</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">brk</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">current_brk</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">brk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_brk</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">brk</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_brk</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">current_brk</span><span class="p">;</span>
<span class="w">  </span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">sz_alloc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">brk</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_brk</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">brk</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Since we wish to use the heap designated by the virtual memory map and not our application's heap, we essentially need to reimplement a very watered down version of the actual system call. Due diligence for system call implementations should be taken when they may modify or interpret host system resources, unless otherwise allowed.
This was a pivotal moment in the development of the emulator, since it allowed more comprehensive validation of the emulator's behaviour, given we could run real compiled binaries that utilised I/O system calls.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><code>a0</code>-<code>a7</code> refer to <code>x10</code>-<code>x17</code>, renamed by the ABI calling convention&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>

    </main>
    <footer>
      <p>-</p>
      
  <a href="/">&gt; home</a>

    </footer>
  </body>
</html>